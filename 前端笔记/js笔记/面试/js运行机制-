

	※js是单线程的
		也就是说，同一个时间只能做一件事。
	※任务队列
		分为：同步任务和异步任务
			同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
			异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
				包含：	setTimeout和setInterval
						DOM事件
						ES6中的Promise
	-------------------------------------------------------------------------------------------------------------------------
	※异步任务的放入时间和执行时间
		放入时间：
			"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，
			"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。
			只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。
		执行时间：
			一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
			"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。
	-------------------------------------------------------------------------------------------------------------------------
	※event loop(事件循环)
		主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。
		只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。
		1.执行栈执行的是同步任务
		2.什么时候往异步队列中放这个任务
			setTimeout和setInterval 
			（当第二个参数缺省时，默认为 0；当指定的值小于 4 毫秒，则增加到 4ms(4ms 是 HTML5 标准指定的，
				对于 2010 年及之前的浏览器则是 10ms);也就是说至少需要4毫秒，该setTimeout()拿到任务队列中。）
			DOM事件（如click、resize等）

			ES6中的Promise
			Ajax异步请求
		3.什么时候去异步队列中取这个任务
			只要主线程空了，就会去读取"任务队列"。	
---------------------------------------------------------------------------------------------------------------------------------------------------
		※setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。
		要是当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在setTimeout()指定的时间执行。
-------------------------------------------------------------------------------------------------------------------------------			
		（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
		（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
		（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
		只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。
		
		"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，
		表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。
		"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。
		只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。
		异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

		"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，
		只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，
		某些事件只有到了规定的时间，才能返回主线程。
		